---
title: "rough work"
author: "Sciper 359523"
date: "2023-05-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r working directory and data, echo=FALSE, include=FALSE}
lapply(c("dplyr","chron","ggplot2","tidyr","questionr","survival","forcats","tidyselect",
         "data.table","table1","lubridate", "ggpubr","viridis","finalfit","survminer",
         "ggpubr", "ggthemes", "gridExtra", "rstatix","stringr",
         "wesanderson","kableExtra", "naniar","boot","scales","ggsci", "stringr",
         "Hmisc","DescTools","swimplot", 'stats', 'EnvStats', 'finalfit'), 
       library, character.only=TRUE)

set.seed(435) #set the seed for reproducible results

#data <- read.csv('data.csv', header=T)
#data_2 <- read.csv('data_2.csv', header=T)
data <- read.csv('owid-covid-data.csv', header = T)
```


# modify the data 
link : https://github.com/owid/covid-19-data/tree/master/public/data
https://ourworldindata.org/coronavirus

```{r}
data <- data %>% filter(continent == 'Europe')

gg_miss_fct(x = data, fct = location)#to see where data is missing 

forbidden <- c('England', 'Scotland', 'Northern Ireland', 'Wales')
data <- subset(data, !(data$location %in% forbidden))

variables_to_keep <- c('location', 'date', 'total_cases', 'new_cases', 'total_cases_per_million', 'new_cases_per_million', 'stringency_index', 'population_density', 'median_age', 'aged_65_older', 'aged_70_older', 'gdp_per_capita', 'extreme_poverty', 'cardiovasc_death_rate', 'diabetes_prevalence', 'female_smokers', 'male_smokers', 'hospital_beds_per_thousand', 'life_expectancy', 'human_development_index', 'population', 'excess_mortality_cumulative_absolute', 'excess_mortality', 'excess_mortality_cumulative_per_million', 'excess_mortality_cumulative')

df <- data[,variables_to_keep]
gg_miss_fct(x = df, fct = location)

#some countries still have lots of missing data so we don't take them 
forbidden <- c('Andorra', 'Faeroe Islands', 'Gibraltar', 'Guernsey', 'Isle of Man', 'Jersey', 'Kosovo', 'Liechtenstein', 'Monaco', 'San Marino', 'Vatican')
df <- subset(df, !(df$location %in% forbidden)) #the data is way better

df <- df %>% mutate(
  date = as.Date(date, format = "%Y-%m-%d")
) 

```


# descriptive statistics 
visualisation des cas 
```{r}
df%>% ggplot(aes(x=date, y=total_cases, color=location)) + geom_line()

df%>% ggplot(aes(x=date, y=new_cases, color=location)) + geom_line()

df%>% ggplot(aes(x=date, y=total_cases_per_million, color=location)) + geom_line()

df%>% ggplot(aes(x=date, y=new_cases_per_million, color=location)) + geom_line()

df <- df %>% mutate(
  log_total_cases = log(total_cases),
  log_total_cases_per_million = log(total_cases_per_million)
)

df%>% ggplot(aes(x=date, y=log_total_cases_per_million, color=location)) + geom_line()
``` 




# smoothing with rolling mean
rolling mean of 7 (weekly reporting pb)
```{r}
library(cowplot)
library(zoo)
#roll <- rollmean(df$log_total_cases_per_million, k=7, align = 'right', fill = NA)

countries <- unique(df$location)
test <- df %>% filter(location == countries[1])
smoothed = rollmean(test$log_total_cases_per_million, k=7, align = 'right', fill = NA)
test$roll_log_cases_per_million <- smoothed
smoothed = rollmean(test$new_cases_per_million, k=7, align = 'right', fill = NA)
test$roll_new_cases_per_million <- smoothed
data_frame <- test

countries <- countries[2:length(countries)]

for (country in countries){
  test <- df %>% filter(location == country)
  smoothed = rollmean(test$log_total_cases_per_million, k=7, align = 'right', fill = NA)
  test$roll_log_cases_per_million <- smoothed
  smoothed = rollmean(test$new_cases_per_million, k=7, align = 'right', fill = NA)
  test$roll_new_cases_per_million <- smoothed
  data_frame <- bind_rows(data_frame,test)
}


df <- df %>% mutate(
  roll_log_cases_per_million = data_frame$roll_log_cases_per_million,
  roll_new_cases_per_million = data_frame$roll_new_cases_per_million
)

df%>% ggplot(aes(x=date, y=roll_log_cases_per_million, color=location)) + geom_line()

df%>% ggplot(aes(x=date, y=roll_new_cases_per_million, color=location)) + geom_line()
```


# smoothing with kernel 
bandwith of 7 since we know there were problems in cases reporting during the week-ends, so we smooth over this window
```{r}
countries <- unique(df$location)

#calcule le smoothed pour chaque 
test <- df %>% filter(location == countries[1])
smoothed = ksmooth(test$date, test$total_cases_per_million, bandwidth = 7, kernel = 'normal')
test$smoothed_cases_per_million <- smoothed$y
smoothed = ksmooth(test$date, test$log_total_cases_per_million, bandwidth = 7)
test$log_smoothed_cases_per_million <- smoothed$y
data_frame <- test

countries <- countries[2:length(countries)]

for (country in countries){
  test <- df %>% filter(location == country)
  smoothed = ksmooth(test$date, test$total_cases, bandwidth = 7)
  test$smoothed_cases_per_million <- smoothed$y
  smoothed = ksmooth(test$date, test$log_total_cases_per_million, bandwidth = 7)
  test$log_smoothed_cases_per_million <- smoothed$y
  data_frame <- bind_rows(data_frame,test)
}

#data_frame%>% ggplot(aes(x=date, y=smoothed_cases_per_million, color=location)) + geom_line()

data_frame%>% ggplot(aes(x=date, y=log_smoothed_cases_per_million, color=location)) + geom_line()

```



# Registering the curves
quand on passe à plus de 10% de la pop on register au début, on s'arrête au premier juillet pour tout le monde 
avec la data smooth par kernel
```{r}
countries <- unique(data_frame$location)
starting_point <- as.Date(numeric(length = length(countries)))

i = 1
for (country in countries){
  data_ <- data_frame%>%filter(location == country)
  m = min(which(data_$roll_log_cases_per_million > 1))
  starting_point[i] <- (data_$date)[m]
  i <- i+1
}

length = as.Date('01-07-2021', format = '%d-%m-%Y') - max(starting_point)

i = 1
data_ <- data_frame%>%filter(location == 'Albania') %>% filter(date >= starting_point[i]) %>% filter(date < starting_point[i] + length ) %>% select(-'date')
data_$time <- 1:length
i = 2
for (country in countries[2:length(countries)]){
  data__ <- data_frame%>%filter(location == country) %>% filter(date >= starting_point[i]) %>% filter(date < starting_point[i] + length)%>% select(-'date')
  data__$time <- 1:length
  data_ <- rbind(data_, data__)
  i <- i+1
}

rm(data__)
#data_ %>% group_by(location) %>% summarise(n = max(time))

data_ %>% group_by(location) %>% ggplot(aes(x=time, y=roll_log_cases_per_million, color=location)) + geom_line()
``` 


# 2e registration
```{r, eval =FALSE}
#data_frame %>% group_by(location) %>% ggplot(aes(x=date, y=new_cases_per_million, color=location)) + geom_line()
#data_frame <- data_frame %>% mutate(diff = diff(roll_new_cases_per_million)/roll_new_cases_per_million)

#data_frame %>% group_by(location) %>% filter(date < as.Date('01-07-2021', format = '%d-%m-%Y')) %>% ggplot(aes(x=date, y=diff, color=location)) + geom_line() + ylim(-5, 10)

#data_frame$roll_new_cases_per_million

#data_ <- data_ %>% mutate(diff = diff(roll_new_cases_per_million)/roll_new_cases_per_million)
countries <- unique(data_$location)

test <- data_ %>% filter(location == countries[1])
test$diff = diff(test$roll_new_cases_per_million)/test$roll_new_cases_per_million
data_frame_2 <- test

countries <- countries[2:length(countries)]


#test <- data_ %>% filter(location == countries[1])
#test$diff = diff(test$roll_new_cases_per_million)/test$roll_new_cases_per_million
#data_frame_2 <- rbind(test, data_frame_2)

for (country in countries){
  test <- data_ %>% filter(location == country)
  test$diff = diff(test$roll_new_cases_per_million)/test$roll_new_cases_per_million
  data_frame_2 <- rbind(data_frame_2,test)
}

data_frame_2 %>% group_by(location) %>%ggplot(aes(x=time, y=diff, color=location)) + geom_line() + ylim(-5, 5)

data_frame_2 %>% filter(location == 'France') %>% ggplot(aes(x=time, y=diff, color=location)) + geom_line()

data_frame_2 %>% filter(location == 'Czechia') %>% ggplot(aes(x=time, y=diff, color=location)) + geom_line()

data_frame_2 %>% filter(location == 'Switzerland') %>% ggplot(aes(x=time, y=diff, color=location)) + geom_line()

data_frame_2 %>% filter(location == 'Belgium') %>% ggplot(aes(x=time, y=diff, color=location)) + geom_line()

data_frame_2 %>% filter(location == 'Spain') %>% ggplot(aes(x=time, y=diff, color=location)) + geom_line()

data_frame_2 %>% filter(location == 'Sweden') %>% ggplot(aes(x=time, y=diff, color=location)) + geom_line()

data_frame_2 %>% filter(location == 'Finland') %>% ggplot(aes(x=time, y=diff, color=location)) + geom_line()

countries
breaking_points <- c(45, 50, 40, 55, 60, 10, 100)

#on veut synchroniser les breaking points
mean = mean(breaking_points)
#france : on shifte de +5, czechia on laisse, suisse on shifte de +10, belgium on shifte de -5, espagne on shifte de -10 : donc on enlève 10 à droite et à gauche au max 
countries_to_keep<-c('France', 'Czechia', 'Switerland', 'Belgium', 'Spain', 'Sweden', 'Finland')
shift <- c(0, 0, 10, -5, -10, 40, 50)
data_frame_2_filtered <- data_frame_2 %>% filter(location %in% countries_to_keep ) 

i=1
data_frame_filtered <- data_frame_2_filtered %>% filter(location == 'France') %>% mutate(
  time = time - shift[i]
)

i=2
for (country in countries_to_keep[2:length(countries_to_keep)]){
  data_frame_filtered <- rbind(data_frame_2_filtered %>% filter(location == country) %>% mutate(time = time - shift[i]), data_frame_filtered)
  i = i+1
}

data_frame_filtered <- data_frame_filtered %>% filter(time >0) %>% filter(time <(as.numeric(length) - max(shift)))

data_frame_filtered %>% group_by(location) %>%ggplot(aes(x=time, y=roll_log_cases_per_million, color=location)) + geom_line()

```


# PCA avec juste les pays, pas de variable en plus
```{r}
col = c('time', 'roll_log_cases_per_million', 'location')
data_pca <- data_[,col]
data_pca <- pivot_wider(data_pca, names_from = location, values_from = roll_log_cases_per_million)
#gg_miss_fct(x = data_pca, fct = time) #on a un intervalle sans données manquantes 

#on enlève les données manquantes
data_pca <- na.omit(data_pca)
data_pca <- data_pca[,2:length(data_pca)]

matrix_pca <- data.matrix(data_pca)









col = c('time', 'roll_log_cases_per_million', 'location')
data_pca <- data_frame_filtered[,col]
data_pca <- pivot_wider(data_pca, names_from = location, values_from = roll_log_cases_per_million)
#gg_miss_fct(x = data_pca, fct = time) #on a un intervalle sans données manquantes 

#on enlève les données manquantes
data_pca <- na.omit(data_pca)
data_pca <- data_pca[,2:length(data_pca)]

matrix_pca <- data.matrix(data_pca)











col = c('time', 'roll_log_cases_per_million', 'location')
data_pca <- data_[,col] %>% filter(location %in%countries_to_keep)
data_pca <- pivot_wider(data_pca, names_from = location, values_from = roll_log_cases_per_million)
#gg_miss_fct(x = data_pca, fct = time) #on a un intervalle sans données manquantes 

#on enlève les données manquantes
data_pca <- na.omit(data_pca)
data_pca <- data_pca[,2:length(data_pca)]

matrix_pca <- data.matrix(data_pca)


```



```{r, eval = FALSE}
col = c('date', 'log_smoothed_cases_per_million', 'location')
data_pca <- data_frame[,col]
data_pca <- pivot_wider(data_pca, names_from = location, values_from = log_smoothed_cases_per_million)
gg_miss_fct(x = data_pca, fct = date) #on a un intervalle sans données manquantes 

#on enlève les données manquantes
data_pca <- na.omit(data_pca)
data_pca <- data_pca[,2:41]

matrix_pca <- data.matrix(data_pca)
```


pca


```{r}
X = t(matrix_pca)

mu <- colMeans(X)
X <- sweep(X,2,mu)

SVD <- svd(X)
Scores <- SVD$u %*% diag(SVD$d)
Loadings <- SVD$v
FVE <- SVD$d^2/sum(SVD$d^2)

par(mfrow = c(3,2))

plot(X[1,]+mu,type="l", ylim=range(X+mu), main="Data and the mean")
for(n in 1:dim(X)[1]) points(X[n,]+mu,type="l")
  points(mu,col=2,lwd=2,type="l")

plot(Scores[1,]*sign(sum(Loadings[,1])), Scores[2,]*sign(sum(Loadings[,2])), main="1st vs 2nd PC scores")


plot(Loadings[,1]*sign(sum(Loadings[,1])),type="l", main=paste0("1st PC (",round(100*FVE[1])," % of var)"))
plot(Loadings[,2]*sign(sum(Loadings[,2])),type="l", main=paste0("2nd PC (",round(100*FVE[2])," % of var)"))
plot(Loadings[,3]*sign(sum(Loadings[,3])),type="l", main=paste0("3rd PC (",round(100*FVE[3])," % of var)"))
plot(Loadings[,4]*sign(sum(Loadings[,4])),type="l", main=paste0("4th PC (",round(100*FVE[4])," % of var)"))
#plot(Loadings[,4]*sign(sum(Loadings[,5])),type="l", main=paste0("5th PC (",round(100*FVE[4])," % of var)"))


#plot(matrix_pca[,1],type="l")
#for(n in 2:10) points(matrix_pca[,n],type="l",col=n,lty=n%%6+1)
#mu <- colMeans(t(matrix_pca[,1:41]))
#points(mu, type="l", lwd=3)
#legend("topleft", legend="mean curve", lwd=3)

``` 


# Ajout d'autres variables ? 

```{r}
#data_pca
#en ajoutant par ex le gdp per capita 
col = c('time', 'location', 'gdp_per_capita')
new_data <- data_[,col]
new_data <- new_data%>%group_by(location, gdp_per_capita) %>%summarise()

matrix_test <- t(data.frame(t(new_data)[2,]))
row.names(matrix_test) <- ('gdp_per_capita')
colnames(matrix_test) <- t(new_data)[1,]

matrix_test <- data.frame(matrix_test)
matrix_test <- data.frame(lapply(matrix_test,as.numeric))
colnames(matrix_test) <- names(data_pca)

data_pca_gdp <- bind_rows(data_pca, matrix_test)


X = t(data.matrix(data_pca_gdp))

mu <- colMeans(X)
X <- sweep(X,2,mu)

#X <- t(X)
SVD <- svd(X)
Scores <- SVD$u %*% diag(SVD$d)
Loadings <- SVD$v
FVE <- SVD$d^2/sum(SVD$d^2)

par(mfrow = c(3,2))

plot(X[1,]+mu,type="l", ylim=range(X+mu), main="Data and the mean")
for(n in 1:dim(X)[1]) points(X[n,]+mu,type="l")
  points(mu,col=2,lwd=2,type="l")

plot(Scores[1,]*sign(sum(Loadings[,1])), Scores[2,]*sign(sum(Loadings[,2])), main="1st vs 2nd PC scores")


plot(Loadings[,1]*sign(sum(Loadings[,1])),type="l", main=paste0("1st PC (",round(100*FVE[1])," % of var)"))

plot(Loadings[,2]*sign(sum(Loadings[,2])),type="l", main=paste0("2nd PC (",round(100*FVE[2])," % of var)"))
plot(Loadings[,3]*sign(sum(Loadings[,3])),type="l", main=paste0("3rd PC (",round(100*FVE[3])," % of var)"))
plot(Loadings[,4]*sign(sum(Loadings[,4])),type="l", main=paste0("4th PC (",round(100*FVE[4])," % of var)"))


```

```{r}
#en ajoutant plusieurs variables 
col = c('location', 'gdp_per_capita', 'median_age', 'female_smokers')
new_data <- data_[,col]
new_data <- new_data%>%group_by(location, gdp_per_capita, median_age, female_smokers) %>%summarise()

matrix_test <- t(data.frame(t(new_data)[2,], t(new_data)[3,], t(new_data)[4,]))
row.names(matrix_test) <- c('gdp_per_capita', 'median_age', 'female_smokers')
colnames(matrix_test) <- t(new_data)[1,]

matrix_test <- data.frame(matrix_test)
matrix_test <- data.frame(lapply(matrix_test,as.numeric))
colnames(matrix_test) <- names(data_pca)

data_pca_new <- bind_rows(data_pca, matrix_test)

data_pca_new <- na.omit(data_pca_new)

```




```{r}
X = t(data_pca_new)

mu <- colMeans(X)
X <- sweep(X,2,mu)

SVD <- svd(X)
Scores <- SVD$u %*% diag(SVD$d)
Loadings <- SVD$v
FVE <- SVD$d^2/sum(SVD$d^2)

par(mfrow = c(3,2))

plot(X[1,]+mu,type="l", ylim=range(X+mu), main="Data and the mean")
for(n in 1:dim(X)[1]) points(X[n,]+mu,type="l")
  points(mu,col=2,lwd=2,type="l")

plot(Scores[1,]*sign(sum(Loadings[,1])), Scores[2,]*sign(sum(Loadings[,2])), main="1st vs 2nd PC scores")


plot(Loadings[,1]*sign(sum(Loadings[,1])),type="l", main=paste0("1st PC (",round(100*FVE[1])," % of var)"))

plot(Loadings[,2]*sign(sum(Loadings[,2])),type="l", main=paste0("2nd PC (",round(100*FVE[2])," % of var)"))
plot(Loadings[,3]*sign(sum(Loadings[,3])),type="l", main=paste0("3rd PC (",round(100*FVE[3])," % of var)"))
plot(Loadings[,4]*sign(sum(Loadings[,4])),type="l", main=paste0("4th PC (",round(100*FVE[4])," % of var)"))


#plot(matrix_pca[,1],type="l")
#for(n in 2:10) points(matrix_pca[,n],type="l",col=n,lty=n%%6+1)
#mu <- colMeans(t(matrix_pca[,1:41]))
#points(mu, type="l", lwd=3)
#legend("topleft", legend="mean curve", lwd=3)

``` 





# with functional data  ? 
peut-être définir une fenêtre de temps (début-fin) ? registration ? 
```{r}
library(fda)
data_pca$time <- seq(1,length(data_pca$Albania), by = 1)

tim_span = 1.5*length(data_pca$Albania)
time = sort(runif(length(data_pca$Albania),0,time_span))
times_basis = seq(0,time_span,1)
knots    = c(seq(0,time_span,5))
n_knots   = length(knots)
n_order   = 4
n_basis   = length(knots) + n_order - 2
basis = create.bspline.basis(c(min(times_basis),max(times_basis)),n_basis,n_order,knots)
n_basis
PHI = eval.basis(time, basis) 
dim(PHI)
matplot(time,PHI,type='l',lwd=1,lty=1, xlab='time',ylab='basis',cex.lab=1,cex.axis=1)
for (i in 1:n_knots)
{
  abline(v=knots[i], lty=2, lwd=1)
}


M = ginv(t(PHI) %*% PHI) %*% t(PHI)
c_hat = M %*% data.matrix(data_pca)
y_hat = PHI %*% c_hat


#and then we do pca ? 
X = t(y_hat)

mu <- colMeans(X)
X <- sweep(X,2,mu)

SVD <- svd(X)
Scores <- SVD$u %*% diag(SVD$d)
Loadings <- SVD$v
FVE <- SVD$d^2/sum(SVD$d^2)

par(mfrow = c(3,2))

plot(X[1,]+mu,type="l", ylim=range(X+mu), main="Data and the mean")
for(n in 1:dim(X)[1]) points(X[n,]+mu,type="l")
  points(mu,col=2,lwd=2,type="l")

plot(Scores[1,]*sign(sum(Loadings[,1])), Scores[2,]*sign(sum(Loadings[,2])), main="1st vs 2nd PC scores")


plot(Loadings[,1]*sign(sum(Loadings[,1])),type="l", main=paste0("1st PC (",round(100*FVE[1])," % of var)"))
plot(Loadings[,2]*sign(sum(Loadings[,2])),type="l", main=paste0("2nd PC (",round(100*FVE[2])," % of var)"))
plot(Loadings[,3]*sign(sum(Loadings[,3])),type="l", main=paste0("3rd PC (",round(100*FVE[3])," % of var)"))
plot(Loadings[,4]*sign(sum(Loadings[,4])),type="l", main=paste0("4th PC (",round(100*FVE[4])," % of var)"))
```























```{r, fig.align="center", fig.cap="Figure 3: Smoothed curves"}
data_frame %>% filter(date <=as.Date('01-07-2021', format = '%d-%m-%Y')) %>% ggplot(aes(x=date, y=roll_log_cases_per_million, color=location)) + geom_line()

```

ADD COMMENT


